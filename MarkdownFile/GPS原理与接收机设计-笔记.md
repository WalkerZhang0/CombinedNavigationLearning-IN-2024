

# GPS原理与接收机设计-笔记

### ch2- GPS信号与导航电文

#### 2.1 载波

波长和频率之间的关系：
$$
\lambda=\frac{c}{f}
$$
载波L1和L2的频率分别为：
$$
f_{1}=1575.42MHz=154f_{0}\\f_{2}=1227.60MHz=120f_{0}\\f_{0}=10.23MHz
$$
基于波长和频率之间的关系，我们可以确定载波的波长。注意波长计算时的单位问题，光速$c$的单位为$m$，相对应的频率单位应该是$HZ$，并且有
$$
1MHz=10^{6}Hz
$$
之所以选择如此大小的频率作为载波频率，有三个原因

1. 特高频包括更高频的电磁波以直射波传播，具有很好的穿透性质，适合数字和卫星通信；
2. 伪码是需要调制在载波之上的，对此要求载波的频率要远大于伪码的频率，而常见的$P(Y)$码的频率已经达到了$20.46MHz$；
3. 也包括载波频率对于GPS接收天线的增益集器尺寸大小的问题；

#### 2.2 伪码

二进制随机序列具有很好的**自相关特性**：简单理解该特点，一组二进制的随机序列在没有相位移时，定义得到的自相关函数最大，而一旦相位移超过了一个码宽，其序列的自相关函数为零，或者说这两种状态下的二进制随机序列正交。

一个二进制随机序列的自相关函数往往定义为：
$$
R_{x}(\iota)=lim_{T\to+\infty}\int_{0}^{T}x(t)x(t-\iota)dt
$$
使用多级反馈的移位寄存器实现具有一定周期且不错的自相关特性的伪随机码，eg：对于一个五级寄存器，除去全为零的无效状态，有**（32-1）**种有效状态；通过C++实现一种在**3和5位置**存在反馈的模拟寄存器：

```c++
#include <stdio.h>
#include <iostream>
#include <string>

using namespace std;

/* 异或相加计算 */
int multiply(int a, int b)
{
    int s = 0;
    if (a != b) s = 1;
    return s;
}

//  实现一个五位寄存器
int main()
{
    int num[5] = { 1, 1, 1, 1, 1 };
    string res = "";
    for (int i = 0; i < 32; i++)
    {
        res += to_string(num[4]);
        int flag = multiply(num[2], num[4]);

        for (int j = 1; j < 5; j++)
        {
            if (j == 4)
            {
                num[5 - j] = num[4 - j];
                num[4 - j] = flag;
            }
            else
                num[5 - j] = num[4 - j];
        }
    }
    cout << res << endl;
    return 0;
}

```

这里对于伪随机码的自相关性有了更加深入的理解。由于伪随机码具有一定范围内的**周期性**，因此，其自相关函数取值往往也具有周期性，当相位移的大小等于一个码的码宽的整数倍时，此时，自相关函数取值为1；而当相位移为一个码宽的整数倍时，自相关函数可以表达成离散的形式。根据离散形式，有一个码在一个周期内与另外一个码之间的相似程度，即**自相关函数的取值等于相同码片值的个数减去不同码片值的个数**；由此甚至可以延伸对于两个同级的m序列，其**互相关函数**的大小等于相同码片值的个数减去不同码片值的个数，这样可以通过互相关函数取值这一参数判断两组**m码的相似程度**。

##### 金码

伪码分三种：m序列/线性伪随机码、组合码和非线性码；

- 伪随机码；

- 组合码：两种或者多种线性码的组合的，金码是组合码的一种，而C/A码本身就是一种金码；

  > 金码由一对级数相等的m序列线性组合而成；

- 非线性码：最安全的一种

关于**如何实现金码中所涉及的两种线性码的线性组合**：使用相位选择器，能够选择从n级寄存单元中的某一个进行输出，这样输出的结果可以看作是从标准线性码向左或向右位移m个码片所得到的结果，从而实现相位移动，再和原始线性码$x_{2}$异或相加，就能够得到金码，一共有$2^{n}-1$种，加之两个线性码的组合，一共就有了$2^{n}+1$种码。

金码非常适合作为扩频、通信系统的信号来源。这主要是因为其**良好自相关性**和**很低的互相关性**。

- 良好的自相关性使得接收机能够通过量测自相关函数的大小确定码的相位移；

- 不同金码之间较低的自相关性使得不同金码在信号传播过程中不会相互干扰，这有利于CDMA，即码分多址的实现；

> 互不干扰其实指的不是信号之间的干扰，而是对于接收机而言，是否容易区分这些信号。

##### C/A码

作为码分多址GPS的关键信号，伪码通过两个十级移位寄存器实现，其包含不同的反馈发生器。理论上说，这两个十级寄存器其实可以产生1025种码，这完全可以满足卫星星座实现码分多址的要求。

##### P码

P码的产生，涉及到不同周期长短的伪码的异或相加计算，短码的异或相加计算需要两个周期长短的最小公倍数，然后扩展两个码至最小公倍数，最后求解扩展后同周期的两者的模2和。

##### GPS信号结构

准确的说，GPS的信号一共包括三个部分，分别是：载波、伪码和数据码。导航电文的信息通过数据码调制，这是因为伪码结构固定，不能存储信息。实际上，通常伪码可以用于区分不同卫星的prn码，即伪随机噪声码，同时，伪码也是所谓的测距码。在信号调制过程中，数据码和伪码异或相加实现扩频，然后二者相加得到的组合码通过双相移位键控（BPSK）对载波进行调制。将数字信号的频宽中心从0转移到载波频率。

调制载波一种有三种方式：调相、调频和调幅。而GPS系统中采用的是**调相**的方式。图2.16很好的表达了这三种调制方式的关系。

接收机端接收到卫星信号后。首先进行载波解调，然后得到扩频后的**组合码（数据码和伪码）**，因为伪码结构已知，可以解扩得到数据码，并且在解扩的过程中也可以获得伪码的相位移，从而获得接收机到卫星距离的测量值。

### ch3-GPS卫星轨道

#### 常用坐标系和时间系统

地球的自转轴本身在不断的发生运动，这主要是因为地球的形状和内部质量分布不均，导致收到来自月球和其他天体的引力的大小和方向发生不断地变化，从而使得自转轴处于不断地变化当中，主要体现在岁差和章动上。如果地球是一个匀质的圆球体，那么就不存在所谓的岁差和章动的现象。

- 惯性坐标系：在空间中处于静止或者保持匀速直线运动的坐标系；

- 地球坐标系：固定在地球上一点，常用于描述地球上一点的空间位置，GPS主要使用地球坐标系，地球坐标系有内化为：

  - 空间直角坐标系/地球直角坐标系：具体定义在大地测量中常见；
  - 空间大地坐标系/大地坐标系：

  > 空间直角坐标系和大地坐标系之间的转换详见大地测量学章节4.3，推导考虑使用直角子午面坐标系；

下面给出转换的公式：大地坐标系$(\phi,\lambda,h)$，地心地固直角坐标系$(x,y,z)$：

大地->直角
$$
x=(N+h)cos(\phi)cos(\lambda)\\y=(N+h)cos(\phi)sin(\lambda)\\z=(N(1-e^2)+h)sin(\phi)
$$
上式中，$N$为卯酉全曲率半径，$e$为椭球第一偏心率：
$$
e^2=\frac{a^2-b^2}{a^2}\\N=\frac{a}{\sqrt{1-e^2sin^2(\phi)}}
$$
直角->大地
$$
\lambda=arctan(\frac{y}{x})\\h=\frac{\sqrt{x^2+y^2}}{\phi}-N\\\phi=arctan[\frac{z}{\sqrt{x^2+y^2}}(1-e^2\frac{N}{N+h})^{-1}]
$$
*注意在直角转大地时，计算$\phi$需要使用迭代逼近*

给出C++的实现代码：

```c++
#include"Calculate.h"
#include<math.h>

#ifndef COORS

#define COORS  // 定义宏
#define a 6378206.4 
#define b 6356583.8
#define e (a*a-b*b)/(a*a)
#define f_inv 294.9786982

class Calculate
{
public:
	double x;
	double y;
	double z;
	double B;
	double L;
	double H;
	bool type_cal;
	Calculate(bool type_cal, double x, double y, double z);

	void xyztoblh();

	void blhtoxyz();

	~Calculate();
};

#endif


#include "Calculate.h"
#include <iostream>

Calculate::Calculate(bool type_cal, double x, double y, double z) // 构造函数
{
	this->type_cal = type_cal;
	if (type_cal)
	{
		this->x = x;
		this->y = y;
		this->z = z;
		this->B = 0.0;
		this->L = 0.0;
		this->H = 0.0;
	}
	else
	{
		this->x = 0.0;
		this->y = 0.0;
		this->z = 0.0;
		this->B = x;
		this->L = y;
		this->H = z;
	}
}

void Calculate::xyztoblh()
{
	double p = sqrt(x * x + y * y);
	double N = a / sqrt(1 - e * e * sin(B) * sin(B));
	double h = p / cos(B) - N;
	double phi = 0.0;
	do
	{
		B = phi;
		phi = atan(z / (p * (1 - e * e * N / (N + h))));
		N = a / sqrt(1 - e * e * sin(phi) * sin(phi));
		h = p / cos(B) - N;
	} while ((phi - B) >= 0.001);
	L = atan(y / x);
	B = phi;
	H = h;
}

void Calculate::blhtoxyz()
{
	double N = a / sqrt(1 - e * e * sin(B) * sin(B));
	x = (N + H) * cos(B) * cos(L);
	y = (N + H) * cos(B) * sin(L);
	z = (N * (1 - e * e) + H) * sin(B);
}

Calculate::~Calculate(){} // 析构函数
```

除了常见的WGS84地心坐标系之外，也存在站心坐标系，其包括东北天三个方向。可以通过旋转变换矩阵实现站心坐标系和地心坐标系之间的转换，同时呢，也可以借助地心坐标系完成站心坐标系和大地坐标系的转换。

可以根据用户和卫星之间的观测矢量来计算出卫星的高度角、天顶角以及方位角。这些计算公式可参见书本P49.

------

简单阐述一下对于时间系统的理解：

在人类的生产生活当中，我们使用的是协调世界时（UTC），这种时间系统时原子时（AT）和世界时（UT）的结合，以原子时所确定的秒长为基础，在时刻上又与世界时偏差保持在0.9s以内。

协调世界时的起算时间和世界时的起算时间是一致的，世界时以地球的自转为基础，但是地球自转的长短处于不断变化当中，有变慢的趋势，每年几乎都变慢1s。为了使协调时和世界时保持一致，在必要的时候，会将协调时进行调秒（Leap Seconds）。

而原子时并不存在这种情况，所以原子时的时间和协调时之间的差异处于不断扩大的变化之中。

GPS时也是以原子时的秒长为基础的，其零时刻与协调世界时在1980年1月6日子夜时刻保一致，因此，在其产生之初就与原子时之间存在一个差异，同时与协调世界时之间也随着后者调秒而不断扩大。我们可以根据GPS卫星的导航电文所提供的参数计算得到GPS时的当下时刻UTC的时间，并且误差往往非常小，**这样就能够实现授时服务**。这些参数位于导航电文的第四子帧的第18页。其中包括$\Delta t_{UTC},A_0,A_1,t_{ot}$.可以通过下式计算出GPS时和协调时之间的差异，继而计算出相应的协调时：
$$
\Delta t_{UTC}=\Delta t_{LS}+A_{0}+A_{1}(t_{E}-t_{ot})\\UTC=t_{E}-\Delta t_{UTC}
$$

> 注意，$(t_{E}-t_{ot})$应该包括两者的星期数差异和对应的描述。$t_{E}$是指GPS时间。

------

GPS系统依靠电磁波在空间中传播实现信息的播发，而这些信号的产生都来已于一个基准频率，该基准频率产生于时钟，稳定的时钟能产生稳定的频率，从而产生精度比较高的信号。GPS卫星种主要采用铷原子钟、铯原子钟等作为卫星时间的参考以及频率基准信号的来源。而考虑到成本问题，接收机端一般采用石英晶体振荡器作为基准频率信号的来源。这种晶体振荡器利用晶体的压电效应，通过施加随机噪声交流电压于晶体上，使其产生形变，形变又会反过来产生电压，对该电压扩大后又反施加给晶体，然后电压中的信号留下了一种能与晶体的谐振频率共存的频率，然后晶体就以该频率振荡起来。

**相对论效应**可以从狭义相对论和广义相对论两个角度考虑：狭义相对论中存在时间和空间的相对性质，同时光速不变定理使得处于高速运动中的物体出现时间膨胀现象，也就是所谓的时间变慢。而广义相对论认为卫星收到地球的时空弯曲度距离越大，则其值越小，从而出现时间便快的情况。

------

##### 卫星的轨道表达

卫星轨道的表达主要依靠开普勒三大定律为依据，在无摄轨道运动之下，使用6个开普勒参数确定卫星在某一时刻的空间位置，这些参数分别为：**轨道升交点赤经$\Omega$（春分点和升交点的地心夹角**）、轨道倾角$i$、近地点角距$\omega$、轨道长半轴$a_{s}$、偏心率$e_{s}$和真近点角$v$。这些参数之中，前五个参数很好的确定了轨道的大小、方位和空间位置；而真近点角确定了在当前时刻下的卫星所处的位置。因此，在这种理想的状态之下，只有真近点角是一个与时间有关的参数，不过，表达出这种时间函数相当复杂，因此引入两个辅助量来表达真近点角，即偏近点角$E$和平近点角$M$。其中，偏近点角和真近点角之间的关系非常类似于大地测量学中的规划纬度和大地纬度的空间关系，而平近点角只是一个虚构的量，没有实际意义。如何使用偏近点角和平近点角表达真近点角，三者之间的关系详见P58.

当得知了真近点角和五个轨道参数后，可以采用极坐标$(r,v)$来表达出卫星在某一时刻的具体位置。轨道平面 的极坐标方程可以表示为：
$$
r=\frac{a_{s}(1-e^2_{s})}{1+e_{s}cosv}
$$
根据轨道平面直角中真近点角和平近点角之间的几何关系，也可以计算求得真近点角和$r$. 

事实上，上述的6个轨道参数只在无摄运动轨道下才能够得以实现，然而在实际情况之中，地球卫星并不只收到来自地球的引力，同样有来自其他天体的影响。并且各个轨道参数也不是固定不变的，都处在与时间有关的变化之中。因此，表征卫星实际位置的星历参数有16个，在基本的开普勒六参数的基础上，增加了10个以对这6个参数进行一定的改正，以保证较为精确的卫星轨道位置的计算。

> x class BaseClass {public:    void baseMethod() {        cout << "Base method" << endl;    }};​class DerivedClass : public BaseClass {public:    void derivedMethod() {        cout << "Derived method" << endl;    }};c#

##### **卫星的轨道计算**

详细计算公式和主要要点参见P61.

xxxxxxxxxx class BaseClass {public:    void baseMethod() {        cout << "Base method" << endl;    }};​class DerivedClass : public BaseClass {public:    void derivedMethod() {        cout << "Derived method" << endl;    }};c#

```C++
void ReadData::calpostion_sat(ReadData::pnav_body navbody)
{
	/* t时刻表示当前时刻；
	 因为星历的有效时间toe为所提供参考时间的+-2h;
	 需要确定当前时刻和toe之间的差值，可以看做是在toe参考时间下的归化时间。
	 需要注意的是归化时间tk的绝对值应该小于7200s，否则说明，该时刻下，这份星历已经不符*/
	double tk = -5749.2777;
	if (abs(tk) >= 7200) cout << "Time is not right" << endl;
	/*计算卫星的平均角速度n*/
	double n = sqrt(mu / (navbody->sqrtA * navbody->sqrtA * navbody->sqrtA* navbody->sqrtA * navbody->sqrtA * navbody->sqrtA)) + navbody->deltan;
	/*计算tk时刻下的平近点角Mk*/
	double Mk = navbody->M0 + n * tk;
	judge_angle(&Mk);
	/*迭代计算偏近点角Ek*/
	double Ek = Mk, flag = 1;
	do
	{
		Ek = Mk + navbody->e * sin(Ek);
		flag++;
	} while (flag > 3);
	/*计算真近点角vk*/
	double vk = atan(sqrt(1 - navbody->e * navbody->e) * sin(Ek) / (cos(Ek) - navbody->e))-PI;
	if (vk<-PI || vk>PI)		cout << "vk is worng" << endl;
	/*计算信号发射时刻的摄动矫正项*/
	double Fayik = vk + navbody->omega;
	double deluk = navbody->Cus * sin(2 * Fayik) + navbody->Cuc * cos(2 * Fayik);
	double delrk = navbody->Crs * sin(2 * Fayik) + navbody->Crc * cos(2 * Fayik);
	double delik = navbody->Cis * sin(2 * Fayik) + navbody->Cic * cos(2 * Fayik);
	/*利用上述改正项改正升交点角距、卫星矢径长度和轨道倾角*/
	double uk = Fayik + deluk;
	double rk = navbody->sqrtA * navbody->sqrtA * (1 - navbody->e * cos(Ek)) + delrk;
	double ik = navbody->i0 + navbody->IDOT * tk + delik;
	/*计算卫星在轨道平面的位置*/
	double xk0 = rk * cos(uk);
	double yk0 = rk * sin(uk);
	/*计算信号发射时刻的升交点赤经Omegak*/
	double Omegak = navbody->OMEGA + (navbody->deltaomega - OMEGAE) * tk - OMEGAE*navbody->TOE;
	/*计算卫星在WGS-84下的直角坐标*/
	navbody->X = xk0 * cos(Omegak) - yk0 * cos(ik) * sin(Omegak);
	navbody->Y = xk0 * sin(Omegak) + yk0 * cos(ik) * cos(Omegak);
	navbody->Z = yk0 * sin(ik);
}
```

在实际GPS测量过程中，尤其是高频率的定位过程中，接收机需要具有非常优秀的计算能力，从而在每一次定位运算中都能够确定至少四颗卫星的位置。但实际上，为了减小GPS接收机的功耗，降低其运算强度相当重要。而考虑到卫星的轨道本身就具有很强的规律性，因此，可以采用插值的方式来确定相近时刻的卫星的位置，从而减小运算强度，并且采用适合的插值方法也不会引入较大的位置或者速度的误差。

### ch4-GPS测量和常见误差

#### 伪距及码相位的理解

所谓“伪距”是指通过测距码获得的携带一定误差的卫星端到接收机端的距离，具体的概念和伪距定位的公式不再展开。主要需要理解的是卫星信号的发射时间和信号的接收时间，以及GPST、接收机钟和卫星钟三者时间之间存在的偏差。

**码相位：**事实证明，测距码当中同样存在码相位这一概念，并且，确定信号的发射时间也依靠的是码相位。（*可能我的理解不是非常准确，注意*！）想要理解码相位，关键在于理解信号的结构。GPS信号是由三个部分构成，分别是载波、测距码和导航电文。三者依次调制，将测距码和数据码通过异或相加实现扩频，并获得组合码，然后通过调相的方式调制在载波上。在接收机接受GPS信号的过程中，通过接收机内部产生的C/A码和C/A码相关器获得码相位。当得知码相位之后，我们可以根据导航电文中一个子帧的遥测字信息获得当前GPS信号的周内时。然后，在当前接收到的信号时刻，可以得到c整周个C/A码以及不足一周的CP（Code Phase）；获得当前这一帧导航电文中的w个字以及b个比特。同时，也能够根据导航电文的子帧的遥测字提供的信息获得周内时TOW（Time of Week）.基于上，我们可以获得信号发射时间$t^s$的构筑公式：
$$
t^{s} = TOW+(30w+b)*0.02+(c+CP/1023)*0.001
$$

#### 多普勒频移和积分多普勒的理解

首先，理解载波相位测量中的关键在于“相位”一词。我对于相位的理解可以表达为载波在当前时刻和产生时刻的差异，这里需要明确“差异”准确的说并不包含整周数。

当运动的接收机接受来自相对于接收机静止的卫星所发射的固定频率的信号时，接收机接收到的实际信号频率会产生变化。这部分瞬间的变化可以将其理解为**多普勒频移**。具体的数学表达为：
$$
f_d=f_r-f
$$
即多普勒频移$f_d$是接收机实际接受信号的频率$f_r$和卫星产生信号的频率$f$之差。可以根据电磁波传播的基本理论出发，严格推导出多普勒频移的计算公式：
$$
f_d=\frac{v}{\lambda}cos(\beta)=\frac{v}{c}fcos(\beta)
$$
角度$\beta$指的是接收机的前进方向和信号入射方向之间的夹角。当接收机想着信号发射端前进时，$\beta$始终小于90度，这是多普勒频移大于零。可以理解为：当接收机向着信号端前进时，其在相同的时间内接收到的载波信号变多了。

上述的内容是基于卫星保持静止的条件下论述的，实际上，卫星也处在运动之中，那么此时，接收机接收到的卫星载波信号的多普勒频移为：
$$
f_d=\frac{(v-v^s)\dot{I}}{\lambda}
$$
这种情况下，其实也可以理解为两者之间的相对速度，只要把接收机看作是在以运动中的卫星为参考系的前提下，就可以类似于静止卫星的多普勒频移的确定。在这种情况下，当接收机和卫星发生相对远离时，多普勒频移为负值，那么接收机的载波相位的变化就会大于卫星的载波相位的变化，此时相位差变大了。*也可以使用上式在已知卫星运动速度的前提下，计算出接收机的运动速度*

积分多普勒就是多普勒频移对时间的积分。对多普勒频移进行积分其实就是等于对多普勒频移所引起的以载波相位周为单位的计数。是不是积分多普勒就是确定整周计数的原理？

### 卡尔曼滤波及其应用

### 惯性导航SINS
